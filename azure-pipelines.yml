pool: 
  vmImage: 'windows-2019'

pr: none

variables:
  - group: vmusers
  - name: 'major'
    value: '1'
  - name: 'minor'
    value: '2'
  - name: 'requiredModules'
    value: 'GuestConfiguration' 
  - name: 'linuxConfigName'
    value: 'firewalldenabled'
  - name: 'windowsConfigName'
    value: 'windowsfirewallenabled'
  - name: 'resourcegroup'
    value: 'rfc_customguestconfig'
  - name: 'storageAccountName'
    value: 'guestconfiguration'
  - name: 'storageContainerName'
    value: 'artifacts'

trigger:
  branches:
    include:
    - master
    - dev
  paths:
    exclude:
    - README.md
    - LICENSE
    - .gitignore
    - .github/*

steps:
- task: PowerShell@2
  inputs:
    targetType: inline
    pwsh: 'false'
    script: |

      # Install required modules from PowerShell Gallery
      Install-Module -Name $(requiredModules),PSScriptAnalyzer `
        -Repository 'PSGallery' `
        -Scope 'CurrentUser' `
        -Verbose `
        -Force
      
  displayName: 'Setup/validate Windows PowerShell environment'

- task: PowerShell@2
  inputs:
    targetType: inline
    pwsh: 'false'
    script: |
      
      # Lint PowerShell scripts
      Invoke-ScriptAnalyzer -Path '$(Build.SourcesDirectory)\guestConfiguration\' `   # Analyzing all files in GuestConfiguration folder (mandatory)
        -IncludeDefaultRules `                                                        # using default PSSA rules until specific rules exist for GC content (optional)
        -Recurse `                                                                    # include all subfolders when looking for PowerShell scripts (optional)
        -Severity Error `                                                             # Only stopping the build if errors are found, parsing issues are ignored (optional)
        -ReportSummary `                                                              # writes details of any issues to build log (optional)
        -EnableExit                                                                   # exits current PowerShell session when complete and returns Exit code based on number of errors found (optional)

  displayName: 'Lint PowerShell scripts in Guest Configuration content'

- task: PowerShell@2
  inputs:
    targetType: inline
    pwsh: 'false'
    script: |

      # Compile DSC MOF files
      
        # Linux configuration
        . $(Build.SourcesDirectory)\guestConfiguration\Linux\$(linuxConfigName).ps1         # dot source the script containing the configuration, to load it in memory
        $(linuxConfigName) -out '$(Build.SourcesDirectory)\guestConfiguration\Linux'        # compile the configuration and output to the Linux folder

        # Windows configuration
        . $(Build.SourcesDirectory)\guestConfiguration\Windows\$(windowsConfigName).ps1     # dot source the script containing the configuration, to load it in memory
        $(windowsConfigName) -out '$(Build.SourcesDirectory)\guestConfiguration\Windows'    # compile the configuration and output to the Windows folder
      
  displayName: 'Compile DSC MOF files'

- task: PowerShell@2
  inputs:
    targetType: inline
    pwsh: 'false'
    script: |

      # Create artifacts folder
      New-Item -Path '$(Build.SourcesDirectory)\artifacts\' -Type Directory
      
      # Create artifacts
      
        # New guest configuration package for Linux
        New-GuestConfigurationPackage -Name '$(linuxConfigName)' `
        -Configuration '$(Build.SourcesDirectory)\guestConfiguration\Linux\$(linuxConfigName).mof' `
        -FilesToInclude '$(Build.SourcesDirectory)\guestConfiguration\Linux\InSpecProfiles' `
        -DestinationPath '$(Build.SourcesDirectory)\artifacts\' `
        -Verbose

        # New guest configuration package for Windows
        New-GuestConfigurationPackage -Name '$(windowsConfigName)' `
        -Configuration '$(Build.SourcesDirectory)\guestConfiguration\Windows\$(windowsConfigName).mof' `
        -DestinationPath '$(Build.SourcesDirectory)\artifacts\' `
        -Verbose
  
  displayName: 'Create content artifacts'

- task: AzureResourceGroupDeployment@2
  inputs:
      azureSubscription: 'ARM'
      location: 'CentralUS'
      resourceGroupName: $(resourcegroup)
      csmFile: '$(Build.SourcesDirectory)\deploymentFiles\deploy.storagecontainer.json'
      overrideParameters: -storageAccountName $(storageAccountName) -containerName $(storageContainerName)

  displayName: 'Create/validate Azure storage account and container'

- task: AzurePowerShell@4
  inputs:
    azureSubscription: 'ARM'
    azurePowerShellVersion: 'latestVersion'
    scriptType: 'inlineScript'
    inline: |

      # Get Storage Context
      $Context = Get-AzStorageAccount -ResourceGroupName $(resourcegroup) -Name $(storageAccountName) | ForEach-Object {$_.Context}

      # Upload files
      Set-AzStorageBlobContent -Context $Context -Container $(storageContainerName) -File '$(Build.SourcesDirectory)\artifacts\$(linuxConfigName)\$(linuxConfigName).zip' -Blob '$(linuxConfigName).zip' -Force -Verbose
      Set-AzStorageBlobContent -Context $Context -Container $(storageContainerName) -File '$(Build.SourcesDirectory)\artifacts\$(windowsConfigName)\$(windowsConfigName).zip' -Blob '$(windowsConfigName).zip' -Force -Verbose

      # Get url with SAS token
      $StartTime = (Get-Date)
      $ExpiryTime = $StartTime.AddYears('3')
      $linuxArtifactSAS = New-AzStorageBlobSASToken -Context $Context -Container $(storageContainerName) -Blob '$(linuxConfigName).zip' -StartTime $StartTime -ExpiryTime $ExpiryTime -Permission rl -FullUri -Verbose
      $windowsArtifactSAS = New-AzStorageBlobSASToken -Context $Context -Container $(storageContainerName) -Blob '$(windowsConfigName).zip' -StartTime $StartTime -ExpiryTime $ExpiryTime -Permission rl -FullUri -Verbose

      # Build Policy parameter tables
      $LinuxPolicyParameterInfo = @(
        @{
            Name = 'DefaultFirewalldProfile'                                                                        # Policy parameter name (mandatory)
            DisplayName = 'Default Firewalld Profile.'                                                              # Policy parameter display name (mandatory)
            Description = "Choose the default profile for Firewalld."                                               # Policy parameter description (optional)
            ResourceType = "ChefInSpecResource"                                                                     # dsc configuration resource type (mandatory)
            ResourceId = 'FirewalldEnabled'                                                                         # dsc configuration resource property name (mandatory)
            ResourcePropertyName = "AttributesYmlContent"                                                           # dsc configuration resource property name (mandatory)
            DefaultValue = 'public'                                                                                 # Policy parameter default value (optional)
            AllowedValues = @('drop','block','public','external','dmz','work','home','internal','trusted')          # Policy parameter allowed values (optional)
        }
      )
      $WindowsPolicyParameterInfo = @(
        @{
            Name = 'EnablePublicProfile'                                                                            # Policy parameter name (mandatory)
            DisplayName = 'Enable Public profile'                                                                   # Policy parameter display name (mandatory)
            Description = "Enables Windows Firewall for Public profile. (0 to Disable, 1 to Enable)"                # Policy parameter description (optional)
            ResourceType = "Registry"                                                                               # dsc configuration resource type (mandatory)
            ResourceId = 'Registry HKLM:\Software\Policies\Microsoft\WindowsFirewall\PublicProfile\EnableFirewall'  # dsc configuration resource property name (mandatory)
            ResourcePropertyName = "ValueData"                                                                      # dsc configuration resource property name (mandatory)
            DefaultValue = '1'                                                                                      # Policy parameter default value (optional)
            AllowedValues = @('0','1')                                                                              # Policy parameter allowed values (optional)
        }
      )
      
      # Overwrite definition/initiative files
      New-GuestConfigurationPolicy -ContentUri $linuxArtifactSAS -DisplayName 'Audit when Firewalld is not enabled' -Description 'Validates that the Firewalld package is installed, running, and that the default zone is public' -Version 1.0.0.0 -DestinationPath '$(Build.SourcesDirectory)\policyFiles\Linux' -Platform Linux -Verbose
      New-GuestConfigurationPolicy -ContentUri $windowsArtifactSAS -DisplayName 'Audit when Windows Firewall is not enabled' -Description 'Validates that the Windows host firewall package is enabled and that the default zone is public' -Version 1.0.0.0 -DestinationPath '$(Build.SourcesDirectory)\policyFiles\Windows' -Platform Windows -Parameter $WindowsPolicyParameterInfo -Verbose
      
      # Publish definitions/initiatives
      $publishedLinuxPolicies = Publish-GuestConfigurationPolicy -Path '$(Build.SourcesDirectory)\policyFiles\Linux\' -Verbose
      $publishedWindowsPolicies = Publish-GuestConfigurationPolicy -Path '$(Build.SourcesDirectory)\policyFiles\Windows\' -Verbose

      # Update InitiativeID so it can be passed to assignment
      $LinuxInitiativeId = (Get-AzPolicySetDefinition -Name $($publishedLinuxPolicies | ? ResourceType -eq 'Microsoft.Authorization/policySetDefinitions' | % Name)).Name
      $WindowsInitiativeId = (Get-AzPolicySetDefinition -Name $($publishedWindowsPolicies | ? ResourceType -eq 'Microsoft.Authorization/policySetDefinitions' | % Name)).Name
      
      # Output values to build variables for later tasks to consume as setvarStep.name
      Write-Host "##vso[task.setvariable variable=LinuxInitiativeId]$LinuxInitiativeId"
      Write-Host "##vso[task.setvariable variable=WindowsInitiativeId]$WindowsInitiativeId"

  displayName: 'Upload artifacts, get SAS tokens and publish definitions/initives'

- task: AzureResourceGroupDeployment@2
  inputs:
      azureSubscription: 'ARM'
      location: 'CentralUS'
      resourceGroupName: $(resourcegroup)
      csmFile: '$(Build.SourcesDirectory)\deploymentFiles\deploy.assignment.json'
      overrideParameters: -assignmentName $(linuxConfigName) -assignmentDisplayName 'Audit when Firewalld is not enabled' -initiativeId $(LinuxInitiativeId) -resourceGroupName $(resourcegroup)
      deploymentOutputs: linuxAssignment

  displayName: 'Deploy Policy assignment for Linux'

- task: AzureResourceGroupDeployment@2
  inputs:
      azureSubscription: 'ARM'
      location: 'CentralUS'
      resourceGroupName: $(resourcegroup)
      csmFile: '$(Build.SourcesDirectory)\deploymentFiles\deploy.assignment.json'
      overrideParameters: -assignmentName $(windowsConfigName) -assignmentDisplayName 'Audit when Windows Firewall is not enabled' -initiativeId $(WindowsInitiativeId) -resourceGroupName $(resourcegroup)
      deploymentOutputs: windowsAssignment

  displayName: 'Deploy Policy assignment for Windows'

- task: AzurePowerShell@4
  inputs:
      azureSubscription: 'ARM'
      azurePowerShellVersion: 'latestVersion'
      scriptType: 'inlineScript'
      inline: |

        # Allow enough time for replication of assignment across geographies
        Start-Sleep -seconds 30

        # Use Policy Insights cmdlets to get assignment ids
        $scope = '/subscriptions/$(subscriptionId)/resourceGroups/$(resourcegroup)'
        
        $linuxAssignmentId = Get-AzPolicyAssignment -Name $(linuxConfigName) -scope $scope
        $windowsAssignmentId = Get-AzPolicyAssignment -Name $(windowsConfigName) -scope $scope

        # Output values to build variables for later tasks to consume as setvarStep.name
        Write-Host "##vso[task.setvariable variable=linuxAssignmentId]$linuxAssignmentId"
        Write-Host "##vso[task.setvariable variable=windowsAssignmentId]$windowsAssignmentId"

  displayName: 'Store assignment ids as build variables for next step'

- task: AzureResourceGroupDeployment@2
  inputs:
      azureSubscription: 'ARM'
      location: 'CentralUS'
      resourceGroupName: $(resourcegroup)
      csmFile: '$(Build.SourcesDirectory)\deploymentFiles\deploy.roleassignment.json'
      overrideParameters: -assignmentName $(linuxAssignmentId) -resourceGroupName $(resourcegroup)

  displayName: 'Deploy Policy role assignment for Linux'

- task: AzureResourceGroupDeployment@2
  inputs:
      azureSubscription: 'ARM'
      location: 'CentralUS'
      resourceGroupName: $(resourcegroup)
      csmFile: '$(Build.SourcesDirectory)\deploymentFiles\deploy.roleassignment.json'
      overrideParameters: -assignmentName $(linuxAssignmentId) -resourceGroupName $(resourcegroup)

  displayName: 'Deploy Policy role assignment for Windows'
  